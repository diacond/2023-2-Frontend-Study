8장 함수
    8.1 함수 정의
        - 선언문, 리터럴, Function생성자, 화살표 함수 표현식
        - 특이사항 : 선언문 제외 나머지 방법은 함수의 정의가 호출보다 꼭 우선이어야 함. hoisting X
        - 중첩 함수 : 함수 속의 함수, C, Java랑 달리 js에서 가능, 근데 if, while 등 제어 구문 안에서는 중첩 X
            - 특이사항 : 중첩함수는 자기를 둘러싼 외부 함수의 인수, 지역 변수에 접근 가능
    8.2 함수 호출
        - 함수 호출, 메소드 호출, 생성자 호출, call or apply사용 간접 호출(9장)
    8.3 함수 인수
        - 인수 생략 -> ex) 필요한 인수가 2갠데 1개만 전달하면, undefined로 됨
        - Argument 객체
            - 인수들을 배열처럼 다루는 객체임 ex) argument[1] = 3; // 2번째 인수를 3으로 재설정
    8.4 재귀 함수
        - 멈추는 조건을 만족할 때까지 계속 반복
    8.5 프로그램 실행 과정
        - 자바 스크립트의 내부 과정?
            - 엔진 : 소스 코드를 보면 평가하고 실행 문맥으로 만든다
                - 실행 가능 코드의 문맥 : 전역, 함수, eval 코드
                    - 왜 갈라짐? 각각 실행 문맥 초기화의 과정이 달라
       - this 값 
            - 함수 호출 당시 거기 속한 객체의 참조값
            - c++과 유사한 개념
        - 가비지 컬렉션, 가비지 컬렉터
            - 사용안하는 객체의 메모리 영역 -> 가비지 컬렉터가 자동으로 해제, 이러한 과정을 가비지 컬렉션이라 함
            - 메모리 누수의 방지
        
    8.8 객체로서의 함수
        - 함수도 객체
            - js의 함수는 function객체임
            - 일급 함수, 일급 객체라서 함수형 프로그래밍 가능

9장 객체
    - 9.1 객체 생성
        - js의 객체 : 이름 + 값을 한 쌍으로 -> property, 객체의 이름 : 프로퍼티 이름 or key
        - 값이 함수의 참조(call by reference)라면 메소드(Method)라고...
        - 객체 생성의 3가지 방법 (객체 리터럴, 생성자, Object.create)
    - 프로토타입 객체에 메소드 정의 -> 같은 메소드를 인스턴스 생성마다 또 만드는 메모리 낭비를 방지한다.
        - 프로토타입 프로퍼티가 가리키는 객체 : 프로토타입 객체 (기본은 빈 객체가리킴)
        - 책에서의 의미 : 인스턴스에 아무것도 정의 안해도 그냥 사용할 수 있는 것 (빈 객체)
        - only readable! 수정 불가.
        this.area = function(){
            return Math.PI*this.radius;
        };
        -> 이거 말고,

        Circle.prototype.area = function(){
            return Math.PI*this.radius;
        };
        -> 이렇게!

        정리 : 이 객체를 통해 만들어진 인스턴스들 안에는 비록 area 메소드가 없다. 하지만 프로토타입 객체의 프로퍼티는 생성자로 만든 모든 인스턴스에서 각각의 프로퍼티처럼 사용가능
                프로토타입이 area라는 메소드를 가리키고 있어서 사용가능.
    -9.2 프로토타입 상속
        - 프로토타입 체인
            - 모든 객체는 내부 프로퍼티 [[Prototype]] 보유 // 함수 객체의 prototype 프로퍼티와는 달라
                - [[]] 말고 __proto__라고 씀 (현 ver)
            - 객체의 __proto__ 프로퍼티는 자신에게 상속해준 부모 객체를 가리킴 -> 객체는 __proto__프로퍼티가 부모 객체를 가리키므로, 부모의 프로퍼티 사용가능
        정리 : 프로토타입 체인 - __proto__프로퍼티가 부모 객체를 가리키므로, 아래 객체에서부터 위로(부모) 객체를 향해서 계속 특정 프로퍼티가 있는지 연쇄 확인
    - 함수 정의, 기본으로 prototype 프로퍼티가짐
    - prototype 객체도 내장된 프로퍼티가짐
        -  constructor , __proto__ 2가지 프로퍼티
    - Object 생성자
    - Object.create - 가장 간단
        - 
    - 9.3 접근자 프로퍼티
        - 프로퍼티의 종류
            - 데이터 프로퍼티 : 이때까지의 프로퍼티, 값의 저장
            - 접근자 프로퍼티 : 값이 없음, 함수를 지정할 수 있는 프로퍼티, 
            - delete로 삭제 가능
        객체의 프로퍼티를 객체 바깥에서 조작하는 것 -> 유지 보수성 해침
        -> 접근자 사용으로 안전하게 바깥에서 조작할 수 있다. (대입, 참조 시 호출되는 메소드)
        (메소드도 프로퍼티다.)
        - getter & setter 함수
            - getter : 접근자 프로퍼티 1개 읽기
            - setter : 접근자 프로퍼티 1개 쓰기
            접근자 프로퍼티에 두 함수 정의 -> function 말고 get, set 키워드를 사용한다.
            - 접.프의 값을 읽으려고 함 -> getter 호출
            - 접.프의 값을 쓰려고 함 -> setter 호출

    - 9.4 프로퍼티의 속성
        - 왜 설정? user가 내장 객체랑 유사하게 일하는 객체를 정의할 수 있다~
        - 프로퍼티의 구조 again - 값 + 이름의 한 쌍 but! 내부 속성 몇 개 더 있음
            - 쓰기 가능
            - 열거 가능
            - 재정의 가능
        - 초기 설정은 전부 1 -> 가능으로 설정
        - 데이터 프로퍼티 (값, 쓰기 가능, 열거 가능, 재정의 가능)
        - 접근자 프로퍼티 (읽기, 쓰기, 열거 가능, 재정의 가능)
        그렇다면 프로퍼티의 속성은 어떻게 설정하지?
        -> 프로퍼티 디스크립터로 설정

    - 9.5 프로퍼티 있나 확인
        - 프로퍼티는 객체 생성 전후에 이것저것 추가가 가능하므로(동적) 확인 필요할 때가 있다.
        확인 방법 : 
            - in 연산자
            - hasOwnProperty 메소드
            -  propertyIsEnumerable 메소드
    - 9.6 프로퍼티를 열거해서 객체 안의 모든 프로퍼티를 다룰 수 있다.
    - 9.7 객체를 fix
    - 9.8 Mixin : 객체a에다가 객체b의 프로퍼티를 붙여서 섞는 방법 , 믹스인

10장 배열
    - 10.1 배열의 메소드
        - 배열은 array타입의 객체
        - Array.prototype의 프로퍼티를 상속받는다. 약간 라이브러리 같은 느낌. 여기 있는 메소드는 모든 배열이 사용가능
        - 주요 메소드
            - 수정 메소드
                - push 메소드 : 배열 끝에 원소 하나 더 밀어넣고 길이를 return
                - shift 메소드 : 배열의 첫 원소 없애고 왼쪽으로 땡기기, 삭제된 원소 값 return
                - unshift 메소드 : 배열 첫 원소 앞에 하나 추가, 오른쪽으로 밀기, 길이를 return
                - splice 메소드 : ex) 배열 앞에서 두개 삭제 후, 거기다가 원소를 끼워넣는다. a b c d -> a x y z d
                - sort 메소드 : 정렬
            - 접근자 메소드 : 수정 x, 배열을 다른 모습으로 가공한 새로운 배열을 반환(원래 배열은 보존)
            - 반복 메소드 : 
    - 10.2 다차원 배열 c++과 동일한 로직 . . .
    - 10.3 유사 배열 객체
        - 굳이 Array타입 아니더라도, 프로퍼티 이름이 0이상의 정수, length 프로퍼티가 있는 객체는 배열처럼 쓸 수 있는데, 얘네가 말그대로 유사 배열 객체다. . .

11장 버그와 오류에 대처하는 방법
    - 11.1 버그 : 디버그
        - 논리 버그, 오타, 실행환경 변화
        - Strict 모드 시용 (엄격) - 애초에 버그가 안나도록
            - function f(x){
                "use strict";
                y = x;
            } // y 가 정의 안된다. undefined
            - 스크릡트 단위로 적용된다. 한 스크립트에서만 적용
        - 스타일 가이드 활용 - 코딩 규칙 정리한 것
        - console 객체를 활용하면서 한줄 한줄 프로그램의 상태 확인. 어디가 문제인가 파악
            - console.log(변수 값 표시) 랑 console.dir(객체의 프로퍼티 목록 표시) 많이 쓴다.
        - 웹 브라우저 (크롬 등)의 개발자 도구 사용 - 콘솔보다 자세하다
        - 프로그램 테스트
    - 11.2 예외 처리
        - throw - catch 문, c++과 같은 개념. . .

12장 정규 표현식
    - 문자열의 패턴 표현을 위한 도구, 크게 일반 문자, 메타 문자로 구성된다.
    - Perl의 정규표현식 -> js로 전달됨
    - 표현 방법 :
        - RegExp 객체 -> var reg = new RegExp("abc");
        - 정규 표현식 리터럴 -> var reg = /abc/;
        - 특수 문자 : 메타 문자라고 부름, 앞에 역슬래시(\)붙여주고 써야한다. (\의 사용 : 이스케이프)
        - 일반 문자 : 리터럴 문자라고 함.

    매칭 : 정규 표현식의 객체와 같은 패턴의 단어, 문자열이 있으면 일치
        - ex) 정규 표현식이 cat인데 문자열이 cat and car면 일치 맞음
    RegExp객체에도 메소드가 있다.
        - 문자열 비교 이후 이런저런 행동들을 함(일치 여부 논리값 반환, 못찾으면 null반환 등. . .)

    정규 표현식 작성법
        - .표현하고 싶으면 \.이라고 쓰기

    search 메소드 : 인수로 정규 표현식 객체를 받으면, 그거랑 똑같은 패턴의 문자열을 찾고 그 인수와 똑같은 부분의 첫 문자 위치를 return!
    var s = "1 little, 2 little indian";
    console.log(s.search(/little/)); // 2 반환

    RegExp 객체에 대하여
        - 프로퍼티 : RegExp.prototype에서 프로퍼티(메소드까지) 상속
            - source, global, ignoreCase, multiline
        - exec 메소드 : 일치하는 문자열 검색후 일치한 부분을 배열에 담아서 return, 없으면 null return
        - lastIndex 프로퍼티 : exec, test 메소드 실행 후 일치한 문자열 바로 다음 번 문자의 위치가 정규 표현식 객체의 lastIndex 프로퍼티에 저장, 일치 x -> 0 저장
            - 다음 메소드 실행시 검색의 시작점을 표시

13장 클라이언트 측 자바스크립트
    웹브라우저에서 js가 하는 일
         - 웹페이지를 동적으로 만듦
         - 웹 브라우저에서 동작하는 웹 애플리케이션 만들수있음
        1. Document 객체 제어(HTML, CSS 스타일 작업)
            - DOM이라는 API활용
        2. 웹페이지의 Window객체 제어 및 브라우저 제어
            - Location, Navigator 같은 객체들 활용
        3. 웹페이지에서 생기는 이벤트 처리
            - 이벤트 처리기, 타이머
        4. HTTP를 이용한 통신 제어
            - XMLHttpRequest객체를 활용
    - 웹 브라우저 : 문자를 웹에서 표시하기 위한 SW였는데, 웹 어플리케이션 실행하는 OS로도 수행
    
    자바스크립트 코드 -> HTML에 삽입
        1. script요소의 내용물로 작성(인라인 스크립트)
        2. 외부파일 읽어오기(외부 스크립트)
        3. 이벤트 처리기 속성에 작성
        4. JavaScript : URL(자바스크립트 의사 프로토콜)
    
    현재 자바스크립트의 표준 : ECMA Script 5 임
    근데 이거 지원안하는 웹브라우저도 있는데, 여기서도 웹 페이지를 표시하도록 하는
        - 크로스 브라우징 대첵 있다.
        - 근데 너무 낮은 점유율인 곳에서는 어렵다.
    
    - Window 객체
        - 전역 객체
        - Window 객체의 프로퍼티 : 전역 변수, 웹 브라우저에서 사용하는 다양한 객체들
        - Window 객체의 프로퍼티, 메소드를 참조하려면? 
            - window 프로퍼티로 참조
              - window.document -> window. 생략가능 -> document
    - Location 객체
        - window.location or location으로 참조 가능
            - document.location도 가능
    
    - History 객체 : 창의 웹페이지 열람 이력을 관리. . .
        - window.history or history 로 참조할수있다.
        복습 ; 모든 객체에는 메소드랑 프로퍼티가 있는데, 메소드도 사실은 프로퍼티임.
    - Navigator 객체 : 스크립트가 실행하고 있는 웹 브라우저의 애플리케이션 정보 관리
        - window.navigator or navigator
    - Screen 객체 : 화면 크기, 색상 등 외관 정보 관리
        - window.screen or screen
    - Document 객체 : 창에 지금 표시되고 있는 웹 페이지 관리
        - 이 객체로 DOM 트리를 읽고 쓸수있다.
        - 얘가 제일 중요함

    - 창을 다루는 법
        - 브라우징 컨텍스트를 각각의 창&탭은 제공한다. 
        - 이렇게 제공된 브라우징 컨텍스트는 별도의 Window 객체를 가진다.
        - 창 여닫기
            - open 메소드
                - var w = open(url, 창의 이름, 옵션);
                - 새로운 창을 여는 메소드 - 즉, 새로운 창의 Window 객체를 반환
        - 창의 크기, 위치 변경
            - 위치 변경 : moveBy & moveTo 메소드
            - 크기 변경 : resizeBy & resizeTo 메소드
            - 패이지 스크롤 : scrollBy & scrollTo 메소드
        - 다른 창을 참조
            - 자식 창의 opener 프로퍼티를 통해서 자식창이 부모창의 객체 참조 가능함

    14장 문서 제어
        - DOM 트리
                document object model
                DOM 의 API들을 써서 HTML 요소를 다루기, CSS 스타일 변경
            트리를 구성하는 객체 하나하나를 노드(node).
                문서 노드
                HTML 요소 노드
                텍스트 노드
            HTML : 공백 무시
            DOM 트리 : 공백을 보고 공백 노드를 생성
                - 첫 공백 마지막 공백은 무시
            노드 객체도 프로퍼티가 있다.
        - HTML 
            - 프로그램의 뼈대같은 느낌. 기초적인 형식들로 웹사이트 구현 가능
            - 요소 
                - 스크롤, 크기, 너비 등의 여러 요소들 세팅 가능
            - 폼
                - 사용자에게 입력을 받는 곳
                - 이름 입력 칸, 날짜 선택 칸, 성별 체크 란 등 다양한 폼 존재
        - CSS 
            - HTML로 만든 뼈대에 세부적인 사항들 추가. (박스의 모양, 글자의 크기, 색, 여백 크기 등)
            - style 프로퍼티로 바꿀수있다.
            - classList 프로퍼티로도 바꿀 수 있음.
        - 정리 : HTML로 먼저 대략적인 형식을 구현하고, CSS로 더 디자인하고 싶은 세부사항을 건드린다. 이후에 Javascript로 함수나 변수를 통해 사이트가 동작하도록 함

    15장 이벤트 처리기
        - 처리기 등록 방법
            - 이벤트 주도형 프로그램에는 이벤트가 발생 시 실행할 함수를 등록해둠
                - 이 함수가 이벤트 처리기(이벤트 리스너). . .
        - 크게 두가지 종류
            - HTML 요소의 이밴트 처리기 속성에 설정
                - + : HTML문서 읽으면서 이벤트 처리기도 같이 설정
                - - : HTML이랑 js랑 섞여서 가독성 별로야
            - DOM 요소 객체의 이벤트 처리기 프로퍼티에 설정
                - HTML이랑 js 분리 작성 -> 가독성 좋고 유지보수도 쉬움
                - 특정 이벤트에 대해 한개만 이벤트 처리기 등록가능
        - 이벤트 리스너를 등록 + 삭제
            - addEventListener
                - 이걸로 등록한 것만 이벤트 리스너라고 한다. 이 방법 이외에 만든 함수는 이벤트 처리기로 구분지어서 부른다.
                - + :  같은 요소의 같은 이벤트에 여러개의 이벤트 리스너 등록 가능
                        버블링 단계, 캡처링 단계 모두 활용(DOM 요소 객체에 직접 등록한 이벤트 "처리기"는 버블링 단계 이벤트만 캡처 가능)
                        HTML요소를 포함한 모든 DOM노드에 이벤트 리스너를 등록 가능
            - removeEventListener

        - 이벤트 객체 : 이벤트 처리기, 이벤트 리스너에 인수로 전달되는 것
            - 객체니까 당연히 프로퍼티 메소드 갖고 있다.
                - 근데 해당 이벤트의 다양한 정보를 저장한 프로퍼티와 이벤트 흐름을 제어하는 메소드를 가짐
                - 공통적으로 모든 이벤트 객체가 가지는 프로퍼티도 있다.
                - 키보드, 마우스 등 입출력 장치가 가지는 고유의 프로퍼티도 있음
    
        - 이벤트 전파: 
            - 단독으로 존재하는 객체에서 발생한 이벤트에 대하여
                - 웹브라우저는 그 단독 객체에 등록된 이밴트 처리기를 호출
                - 이벤트가 HTML요소에서 발생 시 -> 이벤트는 모든 요소에 전파된다.
                    - 즉, 모든 요소의 이벤트 처리기가 호출된다.
            1. 캡처링
            2. 타깃
            3. 버블링

            - 자식 요소에서 발생한 이벤트는 부모 요소에도 전파된다. (의도치 않은 동작의 이유)
                - 해결 : 이벤트 전파를 취소하고 부모 요소가 이밴트 처리 안하게 막음
                - stopPropagation 메소드로 다음요소로 이벤트 전파되는 것을 막을 수 있음.
                - stopImmediatePropagation 메소드로 이밴트 전파를 일시 정지.
                - preventDefault 메소드로 기본 동작을 취소.

        - 이벤트 리스너의 this
            - 이벤트가 발생한 요소의 객체

        - 커스텀 이벤트?
        - 이벤트 객체 생성이 먼저
            - createEvent로 이벤트 객체 생성 후 객체 초기화
            - dispatchEvent 호출해서 이벤트를 보낸다
            - isTrusted -> 1이면 표준 이벤트, 0이면 커스텀 이벤트
            - 왜 씀? 
                - 객체끼리 이벤트를 주고 받으면서 통신하도록 하기 위함.
        
        - 비동기 처리와 Promise
            - Promise : ECMAScript 6부터 추가된 것. 기본적으로 중첩된 코드를 알아보기 쉽도록 작성을 위함
            - 콜백 함수가 많아지면 이해하기가 어려워진다. 시간 순서대로 진행되는 코드가 아니기 떼문.
            - Promise 이용해서 순서대로 처리를 하기 쉽다.
            - resolve & then 메소드
                - onFullfilled함수 : 성공 콜백 함수
            - reject & catch 메소드 
                - onRejected함수 : 실패 콜백 함수

    
        